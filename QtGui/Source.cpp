#include <stdio.h>
#include <iostream>
#include <time.h>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <QtCore>


using namespace cv;
using namespace std;


void getImageDifference();
void getDiffInVideo();


void mainZX()
{


	getDiffInVideo();


}

void getDiffInVideo(){
	//global variables
	Mat frame; //current frame
	Mat resize_blur_Img;
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	Mat binaryImg;
	//Mat TestImg;
	Mat ContourImg; //fg mask fg mask generated by MOG2 method
	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);

	char fileName[100] = "C:\\Users\\dehandecroos\\Desktop\\Videos\\PRG6.avi"; //video\\mm2.avi"; //mm2.avi"; //cctv 2.mov"; //mm2.avi"; //";//_p1.avi";
	VideoCapture stream1(fileName);   //0 is the id of video device.0 if you have only one camera

	//morphology element
	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));

<<<<<<< HEAD




#define drawCross( img, center, color, d )\
line(img, Point(center.x - d, center.y - d), Point(center.x + d, center.y + d), color, 2, CV_AA, 0);\
line(img, Point(center.x + d, center.y - d), Point(center.x - d, center.y + d), color, 2, CV_AA, 0 );


//struct PossibleProfilesMatchBundle
//{
//	vector<models::HumanBlob> *humanB;
//	vector<models::HumanBlob> *possibleP;
//};



unsigned int __stdcall threadForNode(void* data)
{
	char *nodeIdptr = static_cast<char*>(data);
	printf("THREAD [%d]:[%s]:: started.\n", GetCurrentThreadId(), &(*nodeIdptr));

	graph::Node *currentNodePtr = _graph.getNode(&(*nodeIdptr));

	currentNodePtr->ThreadId = GetCurrentThreadId();
	string videoLink = currentNodePtr->IP;
	vector<graph::ExitPoint> exitPoints = currentNodePtr->exitPoints;

	printf("%s :: %d :: %s \n", currentNodePtr->Id.c_str(), currentNodePtr->ThreadId, videoLink.c_str());

	// ###################################################
	//				opencv video tracking

	Mat frame;
	VideoCapture videoCapture(videoLink);
	vector<models::Blob> blobs, unidentifiedBlobs;
	vector<models::HumanBlob> humanBlobs, trackingHumanBlobs, possibleProfileList;
	vector<models::MissingHumanBlob> missingHumanBlobs;

	Mat drawing = Mat::zeros(frame.size(), CV_8UC1);

	VideoProcessing _vProcessing = VideoProcessing();
	Mat fgMaskMOG2;
	Ptr<BackgroundSubtractor> pMOG2 = new BackgroundSubtractorMOG2(300, 32, true);

	if (!(videoCapture.read(frame)))
	{
		cerr << "Problem opening video source" << endl;
		return -1;
	}

	while (waitKey(10) != 27 && videoCapture.grab()) // terminate when ESC pressed
	{
		videoCapture.read(frame);
		/*if (frame.size().width > 1360 || frame.size().height > 760)
		{
			resize(frame, frame, Size(frame.size().width / 2, frame.size().height / 2));
		}*/

		// clear local vectors
		blobs.clear();
		unidentifiedBlobs.clear();
		humanBlobs.clear();


		// ***** should have update after map predicted and detected
		/////////

		// blob detection
		if (_vProcessing.blobDetection(frame, pMOG2, fgMaskMOG2, &blobs) == 0)
		{
			string x = currentNodePtr->Id.c_str();
			imshow(x, frame);
			continue;	// If no blobs detected continue while
		}

		if (trackingHumanBlobs.empty())	// if no human blobs tracked yet
		{
			unidentifiedBlobs = blobs;	// all blobs are unindentified
		}
		else	// if there are human blobs tracked in previous frames
		{
			_vProcessing.dataAssociation(&blobs, &trackingHumanBlobs, &unidentifiedBlobs, &missingHumanBlobs);
		}

		if (!(unidentifiedBlobs.empty()))
		{
			_vProcessing.humanDetection(&unidentifiedBlobs, &frame, &humanBlobs);
		}

		if (!(humanBlobs.empty()))
		{
			_vProcessing.checkInProfiles(&humanBlobs, &possibleProfileList, &missingHumanBlobs, &trackingHumanBlobs);
		}

		if (!(humanBlobs.empty()))
		{
			_vProcessing.initTrackingObject(&humanBlobs, &trackingHumanBlobs);
		}

		if (!(trackingHumanBlobs.empty()))
		{
			_vProcessing.kalmanCorrectAndPredict(&trackingHumanBlobs);
			_vProcessing.informAdjecentNodes(&exitPoints, &trackingHumanBlobs);
			//_vProcessing.UpdateCentralProfiles(&trackingHumanBlobs);
=======
	//unconditional loop
	int skippedFrames = 2500;
	for (int i = 0; i < skippedFrames; i++)
	{
		stream1.grab();

	}
	while (true) {
		const clock_t begin_time = clock();
		Mat cameraFrame;
		if (!(stream1.read(frame))) //get one frame form video
			break;
		imshow("Original", frame);
		//cvtColor(frame, frame, CV_BGR2HSV);
		resize_blur_Img = frame;
		//cvtColor(resize_blur_Img, resize_blur_Img, CV_BGR2HSV);
		//Resize
		//resize(frame, resize_blur_Img, Size(frame.size().width/3, frame.size().height/3) );
		//Blur
		blur(resize_blur_Img, resize_blur_Img, Size(4, 4));
		//Background subtraction
		pMOG2->operator()(resize_blur_Img, fgMaskMOG2, -1);//,-0.5);

		///////////////////////////////////////////////////////////////////
		//pre procesing
		//1 point delete
		//morphologyEx(fgMaskMOG2, fgMaskMOG2, CV_MOP_ERODE, element);
		morphologyEx(fgMaskMOG2, binaryImg, CV_MOP_CLOSE, element);
		//morphologyEx(fgMaskMOG2, testImg, CV_MOP_OPEN, element);

		//Shadow delete
		//Binary
		threshold(binaryImg, binaryImg, 128, 255, CV_THRESH_BINARY);

		//Find contour
		ContourImg = binaryImg.clone();
		//less blob delete
		vector< vector< Point> > contours;
		findContours(ContourImg,
			contours, // a vector of contours
			CV_RETR_EXTERNAL, // retrieve the external contours
			CV_CHAIN_APPROX_NONE); // all pixels of each contours

		vector< Rect > output;
		vector< vector< Point> >::iterator itc = contours.begin();
		while (itc != contours.end()) {

			//Create bounding rect of object
			//rect draw on origin image
			Rect mr = boundingRect(Mat(*itc));
			rectangle(resize_blur_Img, mr, CV_RGB(255, 0, 0),2);
			++itc;
>>>>>>> 564499cb87c97adac23c83808ba014b00ad12cb0
		}

		///////////////////////////////////////////////////////////////////
		qDebug() << "time is " << float(clock() - begin_time) / CLOCKS_PER_SEC;
		qDebug() << " ";
		//Display
		imshow("Shadow_Removed", binaryImg);
		imshow("Detected", resize_blur_Img);
		imshow("MOG2", fgMaskMOG2);

		if (waitKey(5) >= 0)
			break;
	}
}


