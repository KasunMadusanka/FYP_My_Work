//
//  ProBlobDetection.cpp
//  OpencvTut
//
//  Created by Dehan on 4/20/15.
//  Copyright (c) 2015 nephelium. All rights reserved.
//
#include <iostream>

#include "mysql_connection.h"
#include "mysql_driver.h"
#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>
#include <QtWidgets/QApplication>

#include <QtCore\QFileInfo>
#include <QtWidgets\qlabel.h>
#include <fstream>
#include <sys/stat.h>
#include <QtCore\QCoreApplication>
#include <QtCore\qdir.h>
#include <QtCore\QDebug>
#include <QtCore\QString>
#include <stdlib.h>


#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/objdetect/objdetect.hpp"
#include <opencv2/video/background_segm.hpp>

#include "BlobDetection.h"
#include "humanhits.h"
#include "systemdata.h"

#include <Windows.h>
#include <process.h>

#include <stdio.h>
#include <time.h>
using namespace cv;
using namespace std;


struct BlobId{
	vector< Point> surroundingContours;
	string Id;
	int centreX;
	int centreY;


};

vector<BlobId> matchProfilesWithBlobs(vector< vector< Point> > contours, string absoluteTime, string cameraNode){
	HumanHits hh;
	vector<BlobId> profiledBlobs;
	vector<Profile> profilesExisting = hh.getAllProfilesInSecond(absoluteTime, cameraNode);

	//Start comparing blob with existing profile
	int counter = 0;
	for (vector< Point> contour : contours)
	{
		//Find centre of blob
		Moments mom = moments(contour, false);
		Point2f currentCentrePoint = Point2f(mom.m10 / mom.m00, mom.m01 / mom.m00);

		//Map blob to profile, if not found set to UNKNOWN
		double minDistance = -1;
		string minProfile = "UNKNOWN";
		for (int profileCount = 0; profileCount < profilesExisting.size(); profileCount++)
		{
			Profile savedProfile = profilesExisting[profileCount];
			double distance = sqrt(
				(currentCentrePoint.x - savedProfile.centreX)*(currentCentrePoint.x - savedProfile.centreX)
				+
				(currentCentrePoint.y - savedProfile.centreY)*(currentCentrePoint.y - savedProfile.centreY)
				);
			if (minDistance = -1 || minDistance > distance)
			{
				minDistance = distance;
				minProfile = savedProfile.profileId;
				profilesExisting.erase(profilesExisting.begin() + profileCount);
			}

		}
		BlobId blobId;
		blobId.Id = minProfile;
		blobId.surroundingContours = contour;
		blobId.centreX = currentCentrePoint.x;
		blobId.centreY = currentCentrePoint.y;
		profiledBlobs.push_back(blobId);
		counter++;
	}



	return profiledBlobs;
}

int main()
{
	SystemData sd;
	sd.logSystemStartingTime();

	BlobDetection blb;
	Mat src;
	Mat dst;
	Mat resizedFrame;
	Mat processedFrame;
	Mat edgeDetected;

	Mat savedImage;
	Mat savedHist;
	RNG rng(12345);
	Mat frame; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method


	Ptr< BackgroundSubtractor> pMOG2Pointer; //MOG2 Background subtractor
	pMOG2Pointer = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);
	string prefix = "C:\\Users\\dehandecroos\\Desktop\\Videos\\";
	string files[] = { "PRG6.avi",
		"PRG1.avi",
		"PRG28.avi",
		"PRG22.avi",
		"PRG7.avi",
		"PRG14.avi",
		"PRG23.avi",
		"PRG29.avi" };
	for (string file : files){

		string fileName = prefix + file;

		VideoCapture stream1(fileName);

		//morphology element
		
		bool flag = true;

		while (true)
		{
			clock_t t = clock();
			if (!(stream1.read(frame)))
				break;

			vector< vector< Point> > contours;
			BlobDetection blbDetect;
			resize(frame, frame, Size(frame.size().width, frame.size().height));

			Mat originalFrame = frame.clone();

			Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
			contours = blbDetect.detectContours(frame, pMOG2Pointer, fgMaskMOG2);
			Rect roi;
			vector<vector<Point> >hulls;
			vector< vector< Point> > filteredContours;
			QTime startTime = sd.getSystemStartTime();
			int elapsedTime = sd.getElapsedTimeInMilliseconds(startTime);


			while (contours.size() != 0)
			{
				vector<Point> contour = contours[contours.size() - 1];
				if (blbDetect.isQualifyingContour(contour))
				{
					vector<Point> tempHull;
					convexHull(Mat(contour), tempHull, false);
					hulls.push_back(tempHull);
					filteredContours.push_back(contour);
				}
				contours.pop_back();
			}

			int time = static_cast<int>(stream1.get(CV_CAP_PROP_POS_MSEC));
			int mins = static_cast<int>(time / (1000 * 60));
			int seconds = static_cast<int>((time - (mins * 60 * 1000)) / 1000);
			string timeStr;
			if (seconds < 10)
			{
				timeStr = to_string(mins) + ".0" + to_string(seconds);
			}
			else
			{
				timeStr = to_string(mins) + "." + to_string(seconds);
			}

			//Draw the hull borders and fill in white to create the "hullDrawing" mask 
			Mat drawnOnOriginal = originalFrame.clone();
			Mat hullDrawing(frame.size(), CV_8UC3);
			floodFill(hullDrawing, Point(), Scalar(255, 255, 255));
			for (int i = 0; i < filteredContours.size(); i++)
			{
				Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
				drawContours(hullDrawing, hulls, i, color, 1, 8, vector<Vec4i>(), 0, Point());
				drawContours(drawnOnOriginal, hulls, i, color, 1, 8, vector<Vec4i>(), 0, Point());
			}

			//Draw Bounding box
			vector< vector< Point> >::iterator itc = filteredContours.begin();
			while (itc != filteredContours.end()) {

				Rect mr = boundingRect(Mat(*itc));
				rectangle(drawnOnOriginal, mr, CV_RGB(255, 0, 0), 3);
				++itc;
			}

			//Map blobs to profiles
			vector<BlobId> profiledBlobs;
			if (filteredContours.size() != 0){
				profiledBlobs = matchProfilesWithBlobs(filteredContours, timeStr, file);

			}
			//Write Names Blobs
			for (int i = 0; i < profiledBlobs.size(); i++)
			{
				BlobId profiledBlob = profiledBlobs[i];
				Point textOrg(profiledBlob.centreX, profiledBlob.centreY);
				putText(drawnOnOriginal, profiledBlob.Id, textOrg, FONT_HERSHEY_COMPLEX_SMALL, 1, cvScalar(0, 0, 0), 1, CV_AA);
			}
			

			floodFill(hullDrawing, Point(), Scalar(0, 0, 0));
			//Write current timestamp
			putText(drawnOnOriginal, timeStr, cvPoint(30, 30),FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(0, 0, 0), 2, CV_AA);
			imshow("DrawnOnOri", drawnOnOriginal);
			cvWaitKey(1);


		}
	}
	sd.resetSystemStartTime();
	return 0;
}

